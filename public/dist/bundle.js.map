{
  "version": 3,
  "sources": ["../../node_modules/@dynein/state/src/state.ts", "../../node_modules/@dynein/dom/src/dom.ts", "../../src/utils/router.ts", "../../src/pages/home.ts", "../../src/components/header.ts", "../../src/components/projectCard.ts", "../../src/components/iconButton.ts", "../../src/pages/about.ts", "../../src/pages/projects.ts", "../../src/app.ts"],
  "sourcesContent": ["const isSignalSymbol = Symbol(\"isSignal\")\r\n\r\n// Internal state variables\r\n/*\r\n\r\nMeaning of various states\r\n=========================\r\n\r\nassertedStatic = false, collectingDependencies = false\r\n\t* inside an untrack or entirely outside a createEffect\r\n\t* accessing signals does nothing (aside from returning the current signal value)\r\n\r\nassertedStatic = true, collectingDependencies = false\r\n\t* inside an untrack or entirely outside a createEffect\r\n\t* accessing signals causes a warning\r\n\r\nassertedStatic = false, collectingDependencies = true\r\n\t* inside a createEffect or a retrack\r\n\t* accessing signals adds the signal as a dependency of the effect\r\n\r\nassertedStatic = true, collectingDependencies = true\r\n\t* inside a createEffect or a retrack\r\n\t* accessing signals triggers a warning\r\n\t* The signal is *not* added as a dependency of the effect.\r\n\t* (There isn't really a good reason for this situation to appear, but for the sake of something\r\n\t   like defense-in-depth for bugs, it's specified here and handled below in DependencyHandler.read)\r\n\r\nIn other words:\r\n\tassertStatic = true               causes accessing signals to do nothing except trigger a warning\r\n\tcollectingDependencies = false    causes accessing signals to do nothing, but without a warning\r\n\r\nOther notes:\r\n\tThe situation `collectingDependencies && currentEffect` can occur if retrack is called outside an effect\r\n*/\r\nlet assertedStatic = false\r\nlet collectingDependencies = false\r\n\r\ntype ValidCurrentOwnerValue = Owner\r\n\t| null /* root on purpose */\r\n\t| undefined /* root probably not on purpose, so create a warning */\r\n\r\nlet currentOwner: ValidCurrentOwnerValue = undefined\r\nlet currentEffect: Effect | undefined = undefined\r\nlet contextValues = new Map<Context<any>, any>()\r\n\r\n// currentUpdateQueue is also an internal state variable, but it is declared below.\r\n// There are also custom state variables (also see below)\r\n\r\nfunction updateState<T>(\r\n\tnew_assertedStatic: boolean,\r\n\tnew_collectingDependencies: boolean,\r\n\tnew_currentOwner: Owner | null | undefined,\r\n\tnew_currentEffect: Effect | undefined,\r\n\tinner: () => T\r\n) {\r\n\tconst old_assertedStatic = assertedStatic\r\n\tconst old_collectingDependencies = collectingDependencies\r\n\tconst old_currentOwner = currentOwner\r\n\tconst old_currentEffect = currentEffect\r\n\r\n\tassertedStatic = new_assertedStatic\r\n\tcollectingDependencies = new_collectingDependencies\r\n\tcurrentOwner = new_currentOwner\r\n\tcurrentEffect = new_currentEffect\r\n\ttry {\r\n\t\treturn inner()\r\n\t} finally {\r\n\t\tassertedStatic = old_assertedStatic\r\n\t\tcollectingDependencies = old_collectingDependencies\r\n\t\tcurrentOwner = old_currentOwner\r\n\t\tcurrentEffect = old_currentEffect\r\n\t}\r\n}\r\n\r\nexport function _getInternalState() {\r\n\treturn { assertedStatic, collectingDependencies, currentOwner, currentEffect, currentUpdateQueue }\r\n}\r\n\r\nexport { updateState as _updateState }\r\n\r\n\r\n/** STATE CHANGES (template)\r\n * assertedStatic \t       x\r\n * collectingDependencies  x\r\n * currentOwner            x\r\n * currentEffect           x\r\n * contextValues           x\r\n * currentUpdateQueue\t   x\r\n * startDelayed            x\r\n * custom states           x\r\n */\r\n\r\nexport function untrack<T>(inner: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  false\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\r\n\treturn updateState(false, false, currentOwner, currentEffect, inner)\r\n}\r\n\r\nexport function retrack<T>(inner: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  true\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\r\n\treturn updateState(false, true, currentOwner, currentEffect, inner)\r\n}\r\n\r\nconst sample = untrack\r\nexport { sample }\r\n\r\nexport function assertStatic<T>(inner: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       true\r\n\t * collectingDependencies  false\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\r\n\treturn updateState(true, false, currentOwner, currentEffect, inner)\r\n}\r\n\r\nexport function runWithOwner<T>(owner: Owner | null | undefined, inner: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       (preserve)\r\n\t * collectingDependencies  (preserve)\r\n\t * currentOwner            replace\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\treturn updateState(assertedStatic, collectingDependencies, owner, currentEffect, inner)\r\n}\r\n\r\nexport function getOwner(): Owner | null | undefined {\r\n\treturn currentOwner\r\n}\r\n\r\nexport function _runAtBaseWithState<T>(\r\n\tnew_assertedStatic: boolean,\r\n\tnew_collectingDependencies: boolean,\r\n\tnew_currentOwner: Owner | null | undefined,\r\n\tnew_currentEffect: Effect | undefined,\r\n\tinner: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       (from arguments)\r\n\t * collectingDependencies  (from arguments)\r\n\t * currentOwner            (from arguments)\r\n\t * currentEffect           (from arguments)\r\n\t * contextValues           reset to base\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           reset to base\r\n\t */\r\n\tconst restore = getRestoreAllStateFunction()\r\n\ttry {\r\n\t\trestoreBaseState(false)\r\n\t\tassertedStatic = new_assertedStatic\r\n\t\tcollectingDependencies = new_collectingDependencies\r\n\t\tcurrentOwner = new_currentOwner\r\n\t\tcurrentEffect = new_currentEffect\r\n\t\treturn inner()\r\n\t} finally {\r\n\t\trestore()\r\n\t}\r\n}\r\n\r\nexport function createRoot<T>(inner: (dispose: () => void) => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       false (reset)\r\n\t * collectingDependencies  false (reset)\r\n\t * currentOwner            wrapped null (reset)\r\n\t * currentEffect           undefined (reset)\r\n\t * contextValues           reset to base\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           reset to base\r\n\t */\r\n\r\n\tconst owner = new Owner(null)\r\n\treturn _runAtBaseWithState(false, false, owner, undefined, () => inner(() => owner.destroy()))\r\n}\r\n\r\nexport type Context<T> = {\r\n\treadonly defaultValue: T\r\n}\r\n\r\nexport function createContext<T>(): Context<T | undefined>\r\nexport function createContext<T>(defaultValue: T): Context<T>\r\nexport function createContext(defaultValue?: any): Context<any> {\r\n\treturn { defaultValue }\r\n}\r\n\r\nexport function runWithContext<T, R>(context: Context<T>, value: T, inner: () => R): R {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       (preserve)\r\n\t * collectingDependencies  (preserve)\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           modify\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\r\n\tconst oldHas = contextValues.has(context)\r\n\tlet oldValue\r\n\tif (oldHas) {\r\n\t\toldValue = contextValues.get(context)\r\n\t}\r\n\tcontextValues.set(context, value)\r\n\ttry {\r\n\t\treturn inner()\r\n\t} finally {\r\n\t\tif (!oldHas) {\r\n\t\t\tcontextValues.delete(context)\r\n\t\t} else {\r\n\t\t\tcontextValues.set(context, oldValue)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function saveContexts(contexts: Context<any>[]): <T>(inner: () => T) => T {\r\n\tlet restoreContexts = <T>(inner: () => T) => inner()\r\n\r\n\tfor (const ctx of contexts) {\r\n\t\tconst innerRestoreContexts = restoreContexts\r\n\t\tconst val = useContext(ctx)\r\n\t\trestoreContexts = (inner) => runWithContext(ctx, val, () => innerRestoreContexts(inner))\r\n\t}\r\n\r\n\treturn restoreContexts\r\n}\r\n\r\nexport function saveAllContexts(): <T>(inner: () => T) => T {\r\n\t/** STATE CHANGES (after calling inner)\r\n\t * assertedStatic \t       (preserve)\r\n\t * collectingDependencies  (preserve)\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           restore\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            (preserve)\r\n\t * custom states           (preserve)\r\n\t */\r\n\r\n\tconst savedContextValues = new Map(contextValues)\r\n\treturn ((inner) => {\r\n\t\tconst oldContextValues = contextValues\r\n\t\ttry {\r\n\t\t\t// The extra clone here is required to handle restores within restores (see the\r\n\t\t\t// \"handles restores inside restores\" test).\r\n\t\t\tcontextValues = new Map(savedContextValues)\r\n\t\t\treturn inner()\r\n\t\t} finally {\r\n\t\t\tcontextValues = oldContextValues\r\n\t\t}\r\n\t})\r\n}\r\n\r\nexport function useContext<T>(context: Context<T>): T {\r\n\tif (contextValues.has(context)) {\r\n\t\treturn contextValues.get(context)\r\n\t}\r\n\r\n\treturn context.defaultValue\r\n}\r\n\r\n// Any owners created as root (i.e., with `parent` null or undefined)\r\n// are added to this object so that the owners will never be garbage collected.\r\nconst rootOwners = new Set<any>()\r\n\r\n///*DEBUG*/let debugIDCounter = 0\r\n// A simple tree for destroying all descendant contexts when an ancestor is destroyed\r\nexport class Owner {\r\n\t///*DEBUG*/debugID: string\r\n\tprotected children: Set<Owner | (() => void)> = new Set()\r\n\treadonly isDestroyed: boolean = false;\r\n\tprotected parent: Owner | null = null;\r\n\r\n\t///*DEBUG*/protected createContext: any\r\n\t///*DEBUG*/protected destroyContext: any\r\n\r\n\tconstructor(parent: Owner | null | undefined = currentOwner) {\r\n\t\t///*DEBUG*/this.debugID = (debugIDCounter++).toString()\r\n\r\n\t\t///*DEBUG*/this.createContext = new Error(`Create Owner@${this.debugID}`)\r\n\r\n\t\t///*DEBUG*/console.trace(`Owner@${this.debugID}: create`)\r\n\t\tif (parent === undefined) {\r\n\t\t\tconsole.trace(\"Destructables created outside of a `createRoot` will never be disposed.\")\r\n\t\t}\r\n\r\n\t\tif (!parent) {\r\n\t\t\trootOwners.add(this)\r\n\t\t} else {\r\n\t\t\tparent.addChild(this)\r\n\t\t}\r\n\t}\r\n\r\n\tprivate addChild(thing: Owner | (() => void)) {\r\n\t\t///*DEBUG*/console.log(`Owner@${this.debugID}: add child`, thing)\r\n\t\tif (this.isDestroyed) {\r\n\t\t\t///*DEBUG*/console.log(this.createContext, this.destroyContext)\r\n\t\t\t///*DEBUG*/throw new Error(`Owner@${this.debugID}: Can't add to destroyed context.`)\r\n\t\t\tthrow new Error(\"Can't add to destroyed context.\")\r\n\t\t}\r\n\t\tif (thing instanceof Owner) {\r\n\t\t\tthing.parent = this\r\n\t\t}\r\n\t\tthis.children.add(thing)\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\t///*DEBUG*/this.destroyContext = new Error(`Destroy Owner@${this.debugID}`)\r\n\t\t///*DEBUG*/console.log(`Owner@${this.debugID}: destroy`)\r\n\r\n\t\t//@ts-ignore\r\n\t\tthis.isDestroyed = true\r\n\t\tif (this.parent) {\r\n\t\t\tthis.parent.children.delete(this)\r\n\t\t\tthis.parent = null\r\n\t\t}\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\treset() {\r\n\t\t///*DEBUG*/console.log(`Owner@${this.debugID}: reset`)\r\n\t\tconst children = this.children\r\n\r\n\t\t// if one of the child destructors triggers `reset` again, we don't\r\n\t\t// want it to rerun `reset` with the same list, because that would cause an infinite loop\r\n\t\tthis.children = new Set()\r\n\r\n\t\t_runAtBaseWithState(false, false, undefined, undefined, () => {\r\n\t\t\tbatch(() => {\r\n\t\t\t\tfor (const child of children) {\r\n\t\t\t\t\tif (child instanceof Owner) {\r\n\t\t\t\t\t\tchild.parent = null\r\n\t\t\t\t\t\tchild.destroy()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchild()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n\r\nexport type Signal<T> = (() => T) & (<U extends T>(newVal: U) => U) & { [isSignalSymbol]: true }\r\n\r\n// Every ReadableSignal is also a Signal at runtime, but declaring or casting a Signal to a ReadableSignal\r\n// indicates to other functions that it shouldn't be written to.\r\nexport type ReadableSignal<T> = (() => T) & { [isSignalSymbol]: true }\r\n\r\nconst onWriteListenersFunctionsSymbol = Symbol(\"onWriteListeners\")\r\nconst onWriteListenersOwnersSymbol = Symbol(\"onWriteOwners\")\r\nconst onWriteListenersContextValuesSymbol = Symbol(\"onWriteContextValues\")\r\nexport function toSignal<T>(getter: () => T, setter: (value: T) => void): Signal<T> {\r\n\tconst signalWrapper = function (newVal?: T) {\r\n\t\tif (arguments.length === 0) {\r\n\t\t\treturn getter()\r\n\t\t} else {\r\n\t\t\tif (arguments.length !== 1) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\"Expected exactly 0 or 1 arguments to a signal read/write function, got \" +\r\n\t\t\t\t\targuments.length\r\n\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\t//@ts-ignore\r\n\t\t\tif (signalWrapper[onWriteListenersFunctionsSymbol].length > 0) {\r\n\t\t\t\t// Notice that currentUpdateQueue is preserved while all the other state values are reset\r\n\t\t\t\t// to the base values (as if run in the root event loop), or else to the values saved\r\n\t\t\t\t// when the onWrite was created.\r\n\t\t\t\t//\r\n\t\t\t\t// (This is the same as UpdateQueue.tick())\r\n\t\t\t\tconst old_assertedStatic = assertedStatic\r\n\t\t\t\tconst old_collectingDependencies = collectingDependencies\r\n\t\t\t\tconst old_currentOwner = currentOwner\r\n\t\t\t\tconst old_currentEffect = currentEffect\r\n\t\t\t\tconst old_contextValues = contextValues\r\n\t\t\t\tconst restoreCustomStates = customStateStashers.map(stasher => stasher())\r\n\r\n\t\t\t\tassertedStatic = false\r\n\t\t\t\tcollectingDependencies = false\r\n\r\n\t\t\t\t// (Don't need to run these here because they are reset below)\r\n\t\t\t\t// currentOwner = undefined\r\n\t\t\t\t// contextValues = new Map()\r\n\r\n\t\t\t\tfor (const fn of customRestoreBaseStateFunctions) {\r\n\t\t\t\t\tfn()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbatch(() => {\r\n\t\t\t\t\tcurrentEffect = undefined\r\n\r\n\t\t\t\t\t//@ts-ignore\r\n\t\t\t\t\tfor (let i = 0; i < signalWrapper[onWriteListenersOwnersSymbol].length; i++) {\r\n\t\t\t\t\t\t//@ts-ignore\r\n\t\t\t\t\t\tconst owner: Owner = signalWrapper[onWriteListenersOwnersSymbol][i]\r\n\r\n\t\t\t\t\t\t// this cannot be null or undefined because a new owner is created for\r\n\t\t\t\t\t\t// every onWrite\r\n\t\t\t\t\t\towner.reset()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tfor (let i = 0; i < signalWrapper[onWriteListenersFunctionsSymbol].length; i++) {\r\n\t\t\t\t\t\t//@ts-ignore\r\n\t\t\t\t\t\tconst owner: Owner = signalWrapper[onWriteListenersOwnersSymbol][i]\r\n\r\n\t\t\t\t\t\t// this cannot be null or undefined because a new owner is created for\r\n\t\t\t\t\t\t// every onWrite\r\n\t\t\t\t\t\tcurrentOwner = owner\r\n\r\n\t\t\t\t\t\t//@ts-ignore\r\n\t\t\t\t\t\tconst listener = signalWrapper[onWriteListenersFunctionsSymbol][i]\r\n\r\n\t\t\t\t\t\t//@ts-ignore\r\n\t\t\t\t\t\tcontextValues = signalWrapper[onWriteListenersContextValuesSymbol][i]\r\n\r\n\t\t\t\t\t\t// TODO: is it safe to trust the creators of custom states to make sure that\r\n\t\t\t\t\t\t// the functions they pass never throw?\r\n\t\t\t\t\t\tfor (const fn of customRestoreBaseStateFunctions) {\r\n\t\t\t\t\t\t\tfn()\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tlistener(newVal!)\r\n\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\tconsole.warn(\"Caught error in onWrite listener:\", err)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\tassertedStatic = old_assertedStatic\r\n\t\t\t\tcollectingDependencies = old_collectingDependencies\r\n\t\t\t\tcurrentOwner = old_currentOwner\r\n\t\t\t\tcurrentEffect = old_currentEffect\r\n\t\t\t\tcontextValues = old_contextValues\r\n\t\t\t\tfor (const fn of restoreCustomStates) {\r\n\t\t\t\t\tfn()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tsetter(newVal!)\r\n\t\t}\r\n\t\treturn newVal!\r\n\t} as Signal<T>\r\n\r\n\t//@ts-ignore\r\n\tsignalWrapper[isSignalSymbol] = true\r\n\r\n\t//@ts-ignore\r\n\tsignalWrapper[onWriteListenersFunctionsSymbol] = []\r\n\r\n\t//@ts-ignore\r\n\tsignalWrapper[onWriteListenersOwnersSymbol] = []\r\n\r\n\t//@ts-ignore\r\n\tsignalWrapper[onWriteListenersContextValuesSymbol] = []\r\n\r\n\t//@ts-ignore\r\n\treturn signalWrapper\r\n}\r\n\r\nexport function onWrite<T>(getter: ReadableSignal<T>, listener: (newValue: T) => void): void {\r\n\t/** STATE CHANGES (inside listener, relative to their values at listener creation)\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  false\r\n\t * currentOwner            child (reset on rerun)\r\n\t * currentEffect           null\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NOT PRESERVED\r\n\t * startDelayed            true\r\n\t * custom states           null/reset\r\n\t *\r\n\t * (all the state changes are implemented above, not here)\r\n\t */\r\n\r\n\tconst owner = new Owner()\r\n\r\n\t//@ts-ignore\r\n\tgetter[onWriteListenersFunctionsSymbol].push(listener)\r\n\r\n\t//@ts-ignore\r\n\tgetter[onWriteListenersOwnersSymbol].push(owner)\r\n\r\n\t//@ts-ignore\r\n\tgetter[onWriteListenersContextValuesSymbol].push(new Map(contextValues))\r\n\r\n\tonCleanup(() => {\r\n\t\t//@ts-ignore\r\n\t\tconst idx = getter[onWriteListenersFunctionsSymbol].indexOf(listener)\r\n\r\n\t\tif (idx === -1) {\r\n\t\t\tconsole.warn(\"Unexpected internal state in onWrite listener cleanup\")\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// @ts-ignore\r\n\t\tgetter[onWriteListenersFunctionsSymbol].splice(idx, 1)\r\n\r\n\t\t// @ts-ignore\r\n\t\tgetter[onWriteListenersOwnersSymbol].splice(idx, 1)\r\n\r\n\t\t// @ts-ignore\r\n\t\tgetter[onWriteListenersContextValuesSymbol].splice(idx, 1)\r\n\t})\r\n}\r\n\r\nexport function createSignal<T>(initialValue: T, fireWhenEqual: boolean = false): Signal<T> {\r\n\tconst handler = new DependencyHandler(initialValue, fireWhenEqual)\r\n\tconst signal = toSignal(handler.read.bind(handler), handler.write.bind(handler))\r\n\r\n\t// the above makes GC of `handler` depend on GC of `signal`\r\n\r\n\t// This makes GC of `signal` depends on GC of `handler`, so now\r\n\t// GC of signal and handler are linked. (This is important for @dynein/shared-signals)\r\n\thandler.dependents.add(signal)\r\n\r\n\treturn signal\r\n}\r\n\r\nexport function isSignal(thing: any): thing is Signal<any> {\r\n\treturn thing && thing[isSignalSymbol] === true\r\n}\r\n\r\nexport function createEffect(fn: () => (void | Promise<void>)): Owner {\r\n\t/** STATE CHANGES (inside fn, relative to their values at effect creation)\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  true\r\n\t * currentOwner            (created Effect)\r\n\t * currentEffect           (created Effect)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NOT (necessarily) PRESERVED\r\n\t * startDelayed            true\r\n\t * custom states           null/reset\r\n\t */\r\n\r\n\treturn new Effect(fn)\r\n}\r\n\r\nexport function onUpdate<T>(signal: () => T, listener: (newValue: T) => void): Owner {\r\n\t/** STATE CHANGES (inside listener, relative to their values at listener creation)\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  false\r\n\t * currentOwner            child (reset on rerun)\r\n\t * currentEffect           undefined\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NOT PRESERVED\r\n\t * startDelayed            true\r\n\t * custom states           null/reset\r\n\t *\r\n\t * (notice this is the same as onWrite)\r\n\t */\r\n\r\n\tlet isFirst = true\r\n\treturn createEffect(() => {\r\n\t\tconst newValue = signal()\r\n\t\tif (!isFirst) {\r\n\t\t\t// This will be reset after the effect exits, so we don't need to bother resetting it here\r\n\t\t\tcurrentEffect = undefined\r\n\t\t\tcollectingDependencies = false\r\n\r\n\t\t\tbatch(() => {\r\n\t\t\t\tlistener(newValue)\r\n\t\t\t})\r\n\t\t}\r\n\t\tisFirst = false\r\n\t})\r\n}\r\n\r\nexport function createMemo<T>(fn: () => T): () => T {\r\n\t/** STATE CHANGES (inside fn, relative to their values at memo creation)\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  true\r\n\t * currentOwner            internal effect\r\n\t * currentEffect           internal effect\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NOT PRESERVED\r\n\t * startDelayed            true\r\n\t * custom states           null/reset\r\n\t */\r\n\r\n\tlet latestValue: T\r\n\tconst internalSignal = createSignal<T>(undefined as unknown as T)\r\n\r\n\tlet execForced = false\r\n\tconst runUpdate = () => {\r\n\t\tlatestValue = fn()\r\n\t\tif (execForced) {\r\n\t\t\t// We're running inside a subclock, so don't update the signal here, so that we don't\r\n\t\t\t// trigger everything that depends on the signal to also run immediately inside the\r\n\t\t\t// subclock. This is only being run now inside a subclock to return the latest value to\r\n\t\t\t// something being run in a batch.\r\n\t\t} else {\r\n\t\t\tinternalSignal(latestValue)\r\n\t\t}\r\n\t}\r\n\r\n\tconst effect = new Effect(runUpdate)\r\n\r\n\treturn () => {\r\n\t\tif (effect.execPending) {\r\n\t\t\t// We must be in a batch, or else the effect would have already been run\r\n\r\n\t\t\texecForced = true\r\n\t\t\teffect.forceExec()\r\n\t\t\texecForced = false\r\n\r\n\t\t\t// Mark that everything that uses the signal needs an update. (But because this isn't run\r\n\t\t\t// inside the subclock created by forceExec, the updates triggered by this new value change\r\n\t\t\t// (if it really did change) will only be handled after the end of the batch.)\r\n\t\t\tinternalSignal(latestValue)\r\n\t\t}\r\n\r\n\t\t// Log this signal as a dependency\r\n\t\treturn internalSignal()\r\n\t}\r\n}\r\n\r\nexport function createMuffled<T>(signal: Signal<T>): Signal<T> {\r\n\tconst fire = createSignal(true, true)\r\n\tlet updateFromMuffled = false\r\n\tlet triggeringOnWrite = false\r\n\r\n\tconst muffled = toSignal(() => {\r\n\t\tfire()\r\n\t\treturn sample(signal)\r\n\t}, (val: T) => {\r\n\t\tif (triggeringOnWrite) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (currentUpdateQueue.startDelayed) {\r\n\t\t\tupdateFromMuffled = true\r\n\t\t\tcurrentUpdateQueue.onTickEnd.add(() => {\r\n\t\t\t\tupdateFromMuffled = false\r\n\t\t\t})\r\n\t\t\tsignal(val)\r\n\t\t} else {\r\n\t\t\tupdateFromMuffled = true\r\n\t\t\ttry {\r\n\t\t\t\tsignal(val)\r\n\t\t\t} finally {\r\n\t\t\t\tupdateFromMuffled = false\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tonUpdate(signal, () => {\r\n\t\tif (updateFromMuffled) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfire(true)\r\n\t})\r\n\r\n\treturn muffled\r\n}\r\n\r\nexport function onCleanup(fn: () => void) {\r\n\t/** STATE CHANGES (relative to values at creation)\r\n\t *\r\n\t * (most of these are handled in Owner.reset)\r\n\t *\r\n\t * assertedStatic \t       false\r\n\t * collectingDependencies  false\r\n\t * currentOwner            undefined\r\n\t * currentEffect           undefined\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NOT PRESERVED\r\n\t * startDelayed            true\r\n\t * custom states           null/reset\r\n\t */\r\n\r\n\tif (currentOwner === undefined) {\r\n\t\tconsole.trace(\"Destructables created outside of a `createRoot` will never be disposed.\")\r\n\t}\r\n\r\n\tconst savedContextValues = new Map(contextValues)\r\n\r\n\t// Do the ts-ignore to get around the private method warning\r\n\t//@ts-ignore\r\n\tcurrentOwner?.addChild(() => {\r\n\t\tconst old_contextValues = contextValues\r\n\t\ttry {\r\n\t\t\tcontextValues = savedContextValues\r\n\t\t\tfn()\r\n\t\t} catch (err) {\r\n\t\t\tconsole.warn(\"Caught error in cleanup function:\", err)\r\n\t\t} finally {\r\n\t\t\tcontextValues = old_contextValues\r\n\t\t}\r\n\t})\r\n}\r\n\r\nexport function batch<T>(fn: () => T): T {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       (preserve)\r\n\t * collectingDependencies  (preserve)\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   (preserve)\r\n\t * startDelayed            true\r\n\t * custom states           (preserve)\r\n\t */\r\n\treturn currentUpdateQueue.delayStart(fn)\r\n}\r\n\r\nexport function subclock(fn: () => void) {\r\n\t/** STATE CHANGES\r\n\t * assertedStatic \t       (preserve)\r\n\t * collectingDependencies  (preserve)\r\n\t * currentOwner            (preserve)\r\n\t * currentEffect           (preserve)\r\n\t * contextValues           (preserve)\r\n\t * currentUpdateQueue\t   NEW\r\n\t * startDelayed            false\r\n\t * custom states           (preserve)\r\n\t */\r\n\tcurrentUpdateQueue.subclock(fn)\r\n}\r\n\r\n// Necessary since console isn't part of the default Typescript defs, and we don't want to include\r\n// either DOM or @types/node as deps of this module.\r\ninterface Console {\r\n\terror(...data: any[]): void\r\n\tlog(...data: any[]): void\r\n\twarn(...data: any[]): void\r\n\ttrace(...data: any[]): void\r\n}\r\n\r\ndeclare var console: Console\r\n\r\n// Internal class to keep track of pending updates\r\nclass UpdateQueue {\r\n\tparent: UpdateQueue | null\r\n\tthisTick: Set<() => void>\r\n\tnextTick: Set<() => void>\r\n\tonTickEnd: Set<() => void>\r\n\tticking: boolean\r\n\tstartDelayed: boolean\r\n\r\n\tconstructor(parent: UpdateQueue | null = null) {\r\n\t\tthis.parent = parent\r\n\t\tthis.thisTick = new Set()\r\n\t\tthis.nextTick = new Set()\r\n\t\tthis.onTickEnd = new Set()\r\n\t\tthis.ticking = false\r\n\t\tthis.startDelayed = false\r\n\t}\r\n\r\n\tstart() {\r\n\t\tif (this.ticking || this.startDelayed) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet subTickN = 0\r\n\t\tthis.ticking = true\r\n\t\twhile (true) {\r\n\t\t\tif (subTickN > 10000) {\r\n\t\t\t\tconsole.warn(\"Runaway update detected\")\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\r\n\t\t\tsubTickN++\r\n\r\n\t\t\tconst tmp = this.thisTick\r\n\t\t\tthis.thisTick = this.nextTick\r\n\t\t\tthis.nextTick = tmp\r\n\t\t\tthis.nextTick.clear()\r\n\r\n\t\t\tif (this.thisTick.size === 0) {\r\n\t\t\t\tif (this.onTickEnd.size === 0) {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst old_assertedStatic = assertedStatic\r\n\t\t\t\tconst old_collectingDependencies = collectingDependencies\r\n\t\t\t\tconst old_currentOwner = currentOwner\r\n\t\t\t\tconst old_currentEffect = currentEffect\r\n\t\t\t\tconst old_contextValues = contextValues\r\n\t\t\t\tconst restoreCustomStates = customStateStashers.map(stasher => stasher())\r\n\r\n\t\t\t\tassertedStatic = false\r\n\t\t\t\tcollectingDependencies = false\r\n\t\t\t\tcurrentOwner = undefined\r\n\t\t\t\tcurrentEffect = undefined\r\n\t\t\t\tcontextValues = new Map()\r\n\t\t\t\tfor (const fn of customRestoreBaseStateFunctions) {\r\n\t\t\t\t\tfn()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (const fn of this.onTickEnd) {\r\n\t\t\t\t\tthis.onTickEnd.delete(fn)\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tfn()\r\n\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\tconsole.warn(\"Caught error in onBatchEnd function:\", err)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassertedStatic = old_assertedStatic\r\n\t\t\t\tcollectingDependencies = old_collectingDependencies\r\n\t\t\t\tcurrentOwner = old_currentOwner\r\n\t\t\t\tcurrentEffect = old_currentEffect\r\n\t\t\t\tcontextValues = old_contextValues\r\n\t\t\t\tfor (const fn of restoreCustomStates) {\r\n\t\t\t\t\tfn()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontinue // the onTickEnd functions might have added more stuff to nextTick\r\n\t\t\t}\r\n\r\n\t\t\tfor (const fn of this.thisTick) {\r\n\t\t\t\tthis.thisTick.delete(fn)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfn()\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tconsole.warn(\"Caught error in tick function:\", err)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.ticking = false\r\n\t}\r\n\r\n\tsubclock(fn: () => void) {\r\n\t\tthis.unschedule(fn) // Important for having Effect.forceExec not cause unnecessary executions\r\n\r\n\t\tconst oldUpdateQueue = currentUpdateQueue\r\n\t\tcurrentUpdateQueue = new UpdateQueue(this)\r\n\r\n\t\ttry {\r\n\t\t\tfn()\r\n\t\t} finally {\r\n\t\t\tcurrentUpdateQueue = oldUpdateQueue\r\n\t\t}\r\n\t}\r\n\r\n\tdelayStart<T>(fn: () => T): T {\r\n\t\tconst oldStartDelayed = this.startDelayed\r\n\t\tthis.startDelayed = true\r\n\t\ttry {\r\n\t\t\treturn fn()\r\n\t\t} finally {\r\n\t\t\tthis.startDelayed = oldStartDelayed\r\n\t\t\tthis.start()\r\n\t\t}\r\n\t}\r\n\r\n\tunschedule(fn: any) {\r\n\t\tthis.thisTick.delete(fn)\r\n\t\tthis.nextTick.delete(fn)\r\n\t\tthis.parent?.unschedule(fn)\r\n\t}\r\n\r\n\tschedule(fn: () => void) {\r\n\t\tif (this.thisTick.has(fn)) {\r\n\t\t\t// if this is already scheduled on the current tick but not started yet, don't schedule it\r\n\t\t\t// again on the next tick\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.parent?.unschedule(fn)\r\n\t\tthis.nextTick.add(fn)\r\n\t\tthis.start()\r\n\t}\r\n}\r\n\r\nlet currentUpdateQueue = new UpdateQueue()\r\n\r\n// Internal class created by createEffect. Collects dependencies of `fn` and rexecutes `fn` when\r\n// dependencies update.\r\nclass Effect extends Owner {\r\n\tprivate readonly fn: () => void | Promise<void>\r\n\tprivate readonly savedContextValues: Map<Context<any>, any>\r\n\treadonly sources: Set<DependencyHandler<any>>\r\n\tprivate readonly boundExec: () => void\r\n\tdestroyPending: boolean = false\r\n\texecPending: boolean = false\r\n\texecuting: boolean = false\r\n\tsynchronousExecutionDepth = 0\r\n\r\n\tconstructor(fn: () => (void | Promise<void>)) {\r\n\t\tsuper()\r\n\t\tthis.savedContextValues = new Map(contextValues)\r\n\t\tthis.fn = fn.bind(undefined)\r\n\t\tthis.sources = new Set()\r\n\t\tthis.boundExec = this.exec.bind(this)\r\n\t\tthis.boundExec()\r\n\t}\r\n\r\n\tprivate exec() {\r\n\t\tthis.execPending = false\r\n\r\n\t\t// TODO: does there need to be an async version of this somehow...? Invoking async effects\r\n\t\t// while executing is fine because it freezes/discards existing executions\r\n\t\tif (this.synchronousExecutionDepth > 0) {\r\n\t\t\tconsole.error(\"Nested effect self-triggering detected. This is not supported because it can lead to unexpected behavior. The effect will now be destroyed and further executions will be blocked.\")\r\n\t\t\tthis.synchronousExecutionDepth = 0\r\n\t\t\tthis.executing = false\r\n\t\t\tthis.destroy()\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (this.isDestroyed) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst cachedUpdateQueue = currentUpdateQueue // TODO: is this really necessary?\r\n\r\n\t\tconst oldStartDelayed = currentUpdateQueue.startDelayed\r\n\t\tcachedUpdateQueue.startDelayed = true\r\n\r\n\t\tthis.reset()\r\n\t\tfor (const src of this.sources) {\r\n\t\t\tsrc.drains.delete(this)\r\n\t\t}\r\n\t\tthis.sources.clear()\r\n\r\n\t\tconst oldContextValues = contextValues\r\n\r\n\t\tconst restoreCustomStates = customStateStashers.map(stasher => stasher())\r\n\r\n\t\tfor (const fn of customRestoreBaseStateFunctions) {\r\n\t\t\tfn()\r\n\t\t}\r\n\r\n\t\tlet asyncExec = false\r\n\t\ttry {\r\n\t\t\tcontextValues = this.savedContextValues\r\n\r\n\t\t\tthis.synchronousExecutionDepth++\r\n\t\t\tthis.executing = true\r\n\t\t\tconst maybePromise = updateState(false, true, this, this, this.fn)\r\n\t\t\tasyncExec = maybePromise instanceof Promise\r\n\r\n\t\t\tif (asyncExec) {\r\n\t\t\t\t(maybePromise as any).finally(() => {\r\n\t\t\t\t\tthis.executing = false\r\n\t\t\t\t\tif (this.destroyPending) {\r\n\t\t\t\t\t\tthis.destroy()\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tthis.synchronousExecutionDepth--\r\n\r\n\t\t\tif (!asyncExec) {\r\n\t\t\t\tthis.executing = false\r\n\t\t\t}\r\n\r\n\t\t\tcontextValues = oldContextValues\r\n\t\t\tfor (const fn of restoreCustomStates) {\r\n\t\t\t\tfn()\r\n\t\t\t}\r\n\r\n\t\t\t// this applies even if asyncExec is true\r\n\t\t\tif (this.destroyPending) {\r\n\t\t\t\tthis.executing = false\r\n\t\t\t\tthis.destroy()\r\n\t\t\t}\r\n\r\n\t\t\tcachedUpdateQueue.startDelayed = oldStartDelayed\r\n\t\t\tcachedUpdateQueue.start()\r\n\t\t}\r\n\t}\r\n\r\n\tdestroy(force: boolean = false) {\r\n\t\tif (this.sources.size > 0) {\r\n\t\t\tfor (const src of this.sources) {\r\n\t\t\t\tsrc.drains.delete(this)\r\n\t\t\t}\r\n\t\t\tthis.sources.clear() // make garbage collection easier by removing more links\r\n\t\t}\r\n\r\n\t\tif (this.executing && !force) {\r\n\t\t\tthis.destroyPending = true\r\n\t\t\tthis.reset()\r\n\t\t} else {\r\n\t\t\tsuper.destroy()\r\n\t\t}\r\n\r\n\t\t// This may not actually be necessary, but it probably doesn't matter much for performance and\r\n\t\t// it's a safegaurd against memory leaks\r\n\t\tif (this.sources.size > 0) {\r\n\t\t\tfor (const src of this.sources) {\r\n\t\t\t\tsrc.drains.delete(this)\r\n\t\t\t}\r\n\t\t\tthis.sources.clear() // make garbage collection easier by removing more links\r\n\t\t}\r\n\r\n\t\tif (this.isDestroyed) {\r\n\t\t\tthis.executing = false\r\n\t\t\tthis.synchronousExecutionDepth = 0\r\n\t\t}\r\n\t}\r\n\r\n\tschedule() {\r\n\t\tthis.reset() // Destroy subwatchers (and any existing async execution runs)\r\n\t\tthis.execPending = true\r\n\t\tcurrentUpdateQueue.schedule(this.boundExec)\r\n\t}\r\n\r\n\tforceExec() {\r\n\t\tcurrentUpdateQueue.subclock(this.boundExec)\r\n\t}\r\n}\r\n\r\nclass DependencyHandler<T> {\r\n\tvalue: T\r\n\treadonly drains: Set<Effect>\r\n\treadonly fireWhenEqual: boolean\r\n\r\n\treadonly dependents: Set<any> = new Set() // for GC stuff\r\n\r\n\tconstructor(value: T, fireWhenEqual: boolean) {\r\n\t\tthis.value = value\r\n\t\tthis.drains = new Set()\r\n\t\tthis.fireWhenEqual = fireWhenEqual\r\n\t}\r\n\r\n\tread(): T {\r\n\t\tif (collectingDependencies && currentEffect && !assertedStatic && !currentEffect.destroyPending) {\r\n\t\t\tcurrentEffect.sources.add(this)\r\n\t\t\tthis.drains.add(currentEffect)\r\n\t\t} else if (assertedStatic) {\r\n\t\t\tconsole.error(\"Looks like you might have wanted to add a dependency but didn't.\")\r\n\t\t}\r\n\t\treturn this.value\r\n\t}\r\n\r\n\twrite(val: T) {\r\n\t\tconst shouldFire = this.fireWhenEqual || this.value !== val\r\n\t\tthis.value = val\r\n\t\tif (shouldFire) {\r\n\t\t\t// This is basically a copy of the code in UpdateQueue.delayStart, but it avoids creating\r\n\t\t\t// a closure and calling that function. Writing to signals is obviously in the\r\n\t\t\t// really really hot path, so we want to avoid unneeded function calls and closure creation.\r\n\t\t\tconst oldStartDelayed = currentUpdateQueue.startDelayed\r\n\t\t\tcurrentUpdateQueue.startDelayed = true\r\n\r\n\t\t\t// We don't need a try/catch here because there's nothing in .schedule that could throw.\r\n\t\t\t// The only user-controlled code during a schedule is in onCleanup, and that's already\r\n\t\t\t// wrapped inside a try/catch.\r\n\t\t\tfor (const drain of this.drains) {\r\n\t\t\t\tdrain.schedule()\r\n\t\t\t}\r\n\r\n\t\t\tcurrentUpdateQueue.startDelayed = oldStartDelayed\r\n\t\t\tcurrentUpdateQueue.start()\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Returns the value of the condition above inside DependencyHandler.read.\r\nexport function isTracking() {\r\n\treturn collectingDependencies && currentEffect && !assertedStatic && !currentEffect.destroyPending\r\n}\r\n\r\nconst rootUpdateQueue = currentUpdateQueue\r\n\r\ntype StateStasher = () => (() => void)\r\nconst customStateStashers: StateStasher[] = []\r\nconst customRestoreBaseStateFunctions: (() => void)[] = []\r\n\r\nexport function registerCustomStateStasher(stateStasher: StateStasher) {\r\n\tcustomStateStashers.push(stateStasher)\r\n\tcustomRestoreBaseStateFunctions.push(stateStasher())\r\n}\r\n\r\nfunction getRestoreAllStateFunction() {\r\n\tconst old_assertedStatic = assertedStatic\r\n\tconst old_collectingDependencies = collectingDependencies\r\n\tconst old_currentOwner = currentOwner\r\n\tconst old_currentEffect = currentEffect\r\n\tconst old_contextValues = new Map(contextValues)\r\n\r\n\tconst old_currentUpdateQueue = currentUpdateQueue\r\n\tconst old_currentUpdateQueue_startDelayed = currentUpdateQueue.startDelayed\r\n\r\n\tconst restoreCustomStates = customStateStashers.map(stasher => stasher())\r\n\r\n\treturn () => {\r\n\t\tassertedStatic = old_assertedStatic\r\n\t\tcollectingDependencies = old_collectingDependencies\r\n\t\tcurrentOwner = old_currentOwner\r\n\t\tcurrentEffect = old_currentEffect\r\n\r\n\t\t// see the \"handles restores inside restores\" test for why the extra new Map() clone is required\r\n\t\tcontextValues = new Map(old_contextValues)\r\n\r\n\t\tcurrentUpdateQueue = old_currentUpdateQueue\r\n\t\tcurrentUpdateQueue.startDelayed = old_currentUpdateQueue_startDelayed\r\n\r\n\t\tfor (const fn of restoreCustomStates) {\r\n\t\t\tfn()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction restoreBaseState(leavingSynchronousRegion = true) {\r\n\t// leavingSynchronousRegion is true when called from queueMicrotask below, but false when called\r\n\t// from createRoot\r\n\r\n\t///*DEBUG*/console.log(\"restore base state\")\r\n\r\n\t// At the end of a synchronous execution run\r\n\tif (leavingSynchronousRegion && currentEffect && currentEffect.destroyPending) {\r\n\t\tcurrentEffect.destroy(true)\r\n\t}\r\n\r\n\t// Really restore *everything*, because this is called below in stateStashPromise to return\r\n\t// control to the main event loop after leaving a Dynein-wrapped code block.\r\n\t//\r\n\t// This is also called above in createRoot to run code as if it was run outside any other functions.\r\n\tassertedStatic = false\r\n\tcollectingDependencies = false\r\n\tcurrentOwner = undefined\r\n\tcurrentEffect = undefined\r\n\tcontextValues = new Map()\r\n\r\n\tfor (const fn of customRestoreBaseStateFunctions) {\r\n\t\tfn()\r\n\t}\r\n\r\n\tif (leavingSynchronousRegion) {\r\n\t\tcurrentUpdateQueue = rootUpdateQueue\r\n\t\trootUpdateQueue.startDelayed = false\r\n\t\trootUpdateQueue.start()\r\n\t}\r\n}\r\n\r\nexport function stateStashPromise<T>(promise: Promise<T>): Promise<T> {\r\n\tconst restore = getRestoreAllStateFunction()\r\n\tconst maybeResolve = Promise.withResolvers<T>()\r\n\r\n\tlet destroyed = false\r\n\tif (currentOwner) {\r\n\t\tonCleanup(() => {\r\n\t\t\tdestroyed = true\r\n\t\t})\r\n\t}\r\n\r\n\tPromise.allSettled([promise]).then(([result]) => {\r\n\t\t// if the area or execution run that this was called in gets destroyed, simply freeze\r\n\t\t// further execution by not resolving the output promise\r\n\t\tif (destroyed) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\trestore()\r\n\r\n\t\tif (result.status === \"fulfilled\") {\r\n\t\t\tmaybeResolve.resolve(result.value)\r\n\t\t} else {\r\n\t\t\tmaybeResolve.reject(result.reason)\r\n\t\t}\r\n\r\n\t\t// TODO: Should maybe use process.nextTick in node, since process.nextTick runs before\r\n\t\t// microtasks, and thus code in process.nextTick will have state leakage.\r\n\t\t// See: https://stackoverflow.com/a/57325561\r\n\r\n\t\t//@ts-ignore\r\n\t\tqueueMicrotask(restoreBaseState)\r\n\t})\r\n\r\n\treturn maybeResolve.promise\r\n}\r\n\r\nexport { stateStashPromise as $s }\r\n\r\nexport function saveAllState(): <T>(inner: () => T) => T {\r\n\tconst restoreSavePoint = getRestoreAllStateFunction()\r\n\treturn (inner) => {\r\n\t\tconst restoreOuterState = getRestoreAllStateFunction()\r\n\t\ttry {\r\n\t\t\trestoreSavePoint()\r\n\t\t\treturn inner()\r\n\t\t} finally {\r\n\t\t\trestoreOuterState()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport { default as WatchedArray } from \"./WatchedArray.js\"\r\nexport { default as WatchedMap } from \"./WatchedMap.js\"\r\nexport { default as WatchedSet } from \"./WatchedSet.js\"\r\nexport { ReactiveArray, MappableReactiveArray } from \"./ReactiveArray.js\"\r\n", "import { toSignal, onCleanup, assertStatic, createEffect, Owner, batch, untrack, isSignal, sample, retrack, getOwner, runWithOwner, createSignal, registerCustomStateStasher, _updateState, Signal } from \"@dynein/state\"\r\n\r\ntype Primitive = string | number | boolean | undefined | null\r\n\r\nexport type EventsMap<TagMap extends Record<string, any>, ElName extends string> = {\r\n\t[EvName in keyof GlobalEventHandlersEventMap as `on${EvName}`]: (\r\n\t\tthis: TagMap[ElName],\r\n\t\tev: GlobalEventHandlersEventMap[EvName]\r\n\t) => void\r\n}\r\n\r\nexport type AttrsAndEventsMap<TagMap extends Record<string, any>, ElName extends string> = Record<\r\n\tstring,\r\n\tPrimitive | ((...args: any[]) => any)\r\n> & (Partial<EventsMap<TagMap, ElName>>)\r\n\r\nconst updateEventTable: Record<string, string> = {\r\n\tvalue: \"input\",\r\n\tchecked: \"input\",\r\n\tselectedIndex: \"input\" //<select>\r\n}\r\n\r\nfunction replacementArea(start: Node, end: Node, setupReplacements: (replaceInner: <T>(inner: () => T) => T) => void) {\r\n\tlet isFirst = true\r\n\r\n\tlet destroyed = false\r\n\tonCleanup(() => {\r\n\t\tdestroyed = true\r\n\t})\r\n\r\n\tconst parentNode = start.parentNode\r\n\r\n\tsetupReplacements(<T>(inner: () => T) => {\r\n\t\tif (!destroyed) {\r\n\t\t\tif (!start.parentNode) {\r\n\t\t\t\tthrow new Error(\"Unexpected state\")\r\n\t\t\t}\r\n\t\t\tif (!isFirst) {\r\n\t\t\t\tconst range = document.createRange()\r\n\t\t\t\trange.setStartAfter(start)\r\n\t\t\t\trange.setEndBefore(end)\r\n\t\t\t\trange.deleteContents()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tisFirst = false\r\n\t\treturn runWithInsertionState(parentNode, end, () => {\r\n\t\t\treturn assertStatic(inner)\r\n\t\t})\r\n\t})\r\n}\r\n\r\nfunction setAttrOrProp(el: SVGElement | HTMLElement, name: string, val: any) {\r\n\tif (el.namespaceURI === \"http://www.w3.org/2000/svg\" || name.startsWith(\"data-\") || name.startsWith(\"aria-\")) {\r\n\t\tel.setAttribute(name, val)\r\n\t} else {\r\n\t\tif (name === \"class\") {\r\n\t\t\tname = \"className\"\r\n\t\t}\r\n\t\t//@ts-ignore\r\n\t\tel[name] = val\r\n\t}\r\n}\r\n\r\ntype ElementNamespace = \"xhtml\" | \"svg\"\r\ntype ElementTagNameMapForNamespace = {\r\n\txhtml: HTMLElementTagNameMap\r\n\tsvg: SVGElementTagNameMap\r\n}\r\n\r\n// Internal variables and functions used when building DOM structures\r\nlet insertTarget: Node | null = null\r\nlet insertBeforeNode: Node | null = null\r\n\r\nregisterCustomStateStasher(() => {\r\n\tconst old_insertTarget = insertTarget\r\n\tconst old_insertBeforeNode = insertBeforeNode\r\n\r\n\treturn () => {\r\n\t\tinsertTarget = old_insertTarget\r\n\t\tinsertBeforeNode = old_insertBeforeNode\r\n\t}\r\n})\r\n\r\nexport function addNode<T extends Node>(node: T): T {\r\n\tif (insertTarget === null) {\r\n\t\tthrow new Error(\"not rendering\")\r\n\t}\r\n\tif (insertBeforeNode && insertBeforeNode.parentNode !== insertTarget) {\r\n\t\t// Do nothing. The area we're in must have been destroyed since the end node is gone or moved\r\n\t} else {\r\n\t\tinsertTarget.insertBefore(node, insertBeforeNode) // if insertBeforeNode is null, just added to end\r\n\t}\r\n\r\n\treturn node\r\n}\r\n\r\nexport function runWithInsertionState<T>(\r\n\tparentNode: Node | null,\r\n\tbeforeNode: Node | null,\r\n\tinner: () => T\r\n): T {\r\n\tconst old_insertTarget = insertTarget\r\n\tconst old_insertBeforeNode = insertBeforeNode\r\n\tinsertTarget = parentNode\r\n\tinsertBeforeNode = beforeNode\r\n\ttry {\r\n\t\treturn inner()\r\n\t} finally {\r\n\t\tinsertTarget = old_insertTarget\r\n\t\tinsertBeforeNode = old_insertBeforeNode\r\n\t}\r\n}\r\n\r\nexport function getTarget(): Node | null {\r\n\treturn insertTarget\r\n}\r\n\r\nfunction stringify(val: Primitive): string {\r\n\treturn val?.toString() ?? \"\"\r\n}\r\n\r\n// (void | undefined) forces you to not have return values, since that will almost always be a mistake.\r\ntype Inner<T> = ((parent: T) => (void | undefined)) | Primitive\r\n\r\nfunction wrapEventListener(fn: any) {\r\n\tconst owner = new Owner()\r\n\treturn function wrappedListener() {\r\n\t\towner.reset()\r\n\t\t_updateState(false, false, owner, undefined, () => {\r\n\t\t\t//@ts-ignore\r\n\t\t\tfn.apply(this, arguments)\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunction createSignalUpdateListener(el: any, attr: string, sig: Signal<any>) {\r\n\treturn () => {\r\n\t\tsig(el[attr])\r\n\t}\r\n}\r\n\r\nfunction createAndInsertElement<\r\n\tNamespace extends ElementNamespace,\r\n\tTagName extends string & keyof ElementTagNameMapForNamespace[Namespace]\r\n>(\r\n\tnamespace: Namespace,\r\n\ttagName: TagName,\r\n\tattrs: AttrsAndEventsMap<ElementTagNameMapForNamespace[Namespace], TagName> | null,\r\n\tinner: Inner<Node>\r\n): Node {\r\n\t// See https://stackoverflow.com/a/28734954\r\n\tlet el: SVGElement | HTMLElement\r\n\tif (namespace === \"svg\") {\r\n\t\tel = document.createElementNS(\"http://www.w3.org/2000/svg\", tagName)\r\n\t} else {\r\n\t\tel = document.createElement(tagName)\r\n\t}\r\n\r\n\tif (attrs) {\r\n\t\tfor (const attributeName in attrs) {\r\n\t\t\t//@ts-ignore\r\n\t\t\tconst val = attrs[attributeName]\r\n\t\t\tif (attributeName.startsWith(\"on\")) {\r\n\t\t\t\tif (val === undefined || val === null) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof val !== \"function\") {\r\n\t\t\t\t\tthrow new Error(\"Listeners must be functions.\")\r\n\t\t\t\t}\r\n\t\t\t\tel.addEventListener(attributeName.substring(2).toLowerCase(), wrapEventListener(val))\r\n\t\t\t} else if (typeof val === \"function\") {\r\n\t\t\t\tif (isSignal(val)) {\r\n\t\t\t\t\tconst updateEventName: string | undefined = updateEventTable[attributeName]\r\n\t\t\t\t\tif (updateEventName) {\r\n\t\t\t\t\t\tel.addEventListener(updateEventName, createSignalUpdateListener(el, attributeName, val))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t`No update event in table for attribute \"${attributeName}\", so couldn't bind.`\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t//fallthrough to watch below\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcreateEffect(() => {\r\n\t\t\t\t\t// TODO: this will be re-run whenever the value signal changes, even if the signal\r\n\t\t\t\t\t// was updated by the addEventListener above and the signal is already in sync\r\n\t\t\t\t\t// with the DOM. There isn't a good way to stop this effect from running again,\r\n\t\t\t\t\t// but we can stop the redundant setAttrOrProp call by caching the last value we\r\n\t\t\t\t\t// got from the DOM. Would that be worth it? Might it cause unexpected behavior\r\n\t\t\t\t\t// if people manually assign to the element .value attribute?\r\n\t\t\t\t\tconst rawVal = val() ?? \"\"\r\n\t\t\t\t\tsetAttrOrProp(el, attributeName, rawVal)\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tsetAttrOrProp(el, attributeName, val)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (inner !== null) {\r\n\t\tif (typeof inner === \"function\") {\r\n\t\t\t//console.log(`<${tagName}>`)\r\n\t\t\trunWithInsertionState(el, null, () => {\r\n\t\t\t\tinner(el)\r\n\t\t\t})\r\n\t\t\t//console.log(`</${tagName}>`)\r\n\t\t} else {\r\n\t\t\tel.appendChild(document.createTextNode(stringify(inner)))\r\n\t\t}\r\n\t}\r\n\r\n\t//special case to init selects properly. This has to be done after the options list has been\r\n\t// added by inner()\r\n\tif (tagName === \"select\" && attrs && namespace === \"xhtml\") {\r\n\t\tconst specialSelectAttrs = [\"value\", \"selectedIndex\"]\r\n\t\tfor (const attr of specialSelectAttrs) {\r\n\t\t\tif (attr in attrs) {\r\n\t\t\t\t//@ts-ignore\r\n\t\t\t\tconst val = attrs[attr]\r\n\t\t\t\tif (typeof val === \"function\") {\r\n\t\t\t\t\tconst rawVal = sample(val) ?? \"\"\r\n\t\t\t\t\tsetAttrOrProp(el, attr, rawVal)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsetAttrOrProp(el, attr, (val as any) ?? \"\")\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddNode(el)\r\n\treturn el\r\n}\r\n\r\ntype MakeBoundCreateFunc<TagNameMap extends Record<string, any>, TagName extends string & keyof TagNameMap> =\r\n\t((attrs: AttrsAndEventsMap<TagNameMap, TagName>) => TagNameMap[TagName]) &\r\n\t((attrs: AttrsAndEventsMap<TagNameMap, TagName>, inner: Inner<TagNameMap[TagName]>) => TagNameMap[TagName]) &\r\n\t((inner: Inner<TagNameMap[TagName]>) => TagNameMap[TagName]) &\r\n\t(() => TagNameMap[TagName])\r\n\r\nexport type BoundCreateFunc<\r\n\tNamespace extends ElementNamespace,\r\n\tTagName extends string & keyof ElementTagNameMapForNamespace[Namespace]\r\n> = MakeBoundCreateFunc<ElementTagNameMapForNamespace[Namespace], TagName>\r\n\r\nexport type CreationProxy<Namespace extends ElementNamespace> = {\r\n\t[K in keyof ElementTagNameMapForNamespace[Namespace] & string]: BoundCreateFunc<Namespace, K>\r\n}\r\n\r\nfunction makeCreateElementsProxy<Namespace extends ElementNamespace>(namespace: Namespace) {\r\n\treturn new Proxy(Object.create(null), {\r\n\t\tget(target, tagName, receiver) {\r\n\t\t\tif (typeof tagName !== \"string\") {\r\n\t\t\t\tthrow new Error(\"tagName must be a string\")\r\n\t\t\t}\r\n\t\t\tfunction boundCreate(a?: any, b?: any) { //implementation of the BoundCreate overload\r\n\t\t\t\tconst aIsObject = typeof a === \"object\"\r\n\t\t\t\tif (a === undefined && b === undefined) {\r\n\t\t\t\t\treturn createAndInsertElement(namespace, tagName as any, null, null)\r\n\t\t\t\t} else if (aIsObject && b === undefined) {\r\n\t\t\t\t\treturn createAndInsertElement(namespace, tagName as any, a, null)\r\n\t\t\t\t} else if (b === undefined) {\r\n\t\t\t\t\treturn createAndInsertElement(namespace, tagName as any, null, a)\r\n\t\t\t\t} else if (aIsObject) {\r\n\t\t\t\t\treturn createAndInsertElement(namespace, tagName as any, a, b)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"Unexpected state\")\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn boundCreate\r\n\t\t}\r\n\t})\r\n}\r\n\r\nexport const elements = makeCreateElementsProxy(\"xhtml\") as CreationProxy<\"xhtml\">\r\nexport const svgElements = makeCreateElementsProxy(\"svg\") as CreationProxy<\"svg\">\r\n\r\nlet idCounter = 0\r\nexport function createUniqueId(): string {\r\n\treturn \"__d\" + (idCounter++)\r\n}\r\n\r\nexport function addHTML(html: string): void {\r\n\tif (typeof html !== \"string\" && typeof html !== \"number\") {\r\n\t\tthrow new Error(\"HTML must be a string or number\")\r\n\t}\r\n\tconst tmp = document.createElement(\"template\")\r\n\ttmp.innerHTML = html\r\n\tconst frag = tmp.content\r\n\taddNode(frag)\r\n}\r\n\r\nexport function addText(val: Primitive | (() => Primitive)): Node {\r\n\tconst node = document.createTextNode(\"\")\r\n\trunWithInsertionState(null, null, () => {\r\n\t\tif (typeof val === \"function\") {\r\n\t\t\tcreateEffect(() => {\r\n\t\t\t\tnode.textContent = stringify(val())\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tnode.textContent = stringify(val)\r\n\t\t}\r\n\t})\r\n\treturn addNode(node)\r\n}\r\n\r\nexport function addPortal(parentNode: Node, inner: () => void): void\r\nexport function addPortal(parentNode: Node, beforeNode: Node | null, inner: () => void): void\r\nexport function addPortal(parentNode: Node, beforeOrInner: Node | null | (() => void), maybeInner?: () => void) {\r\n\tlet inner: () => void\r\n\tlet beforeNode: Node | null\r\n\tif (typeof beforeOrInner === \"function\") {\r\n\t\tinner = beforeOrInner\r\n\t\tbeforeNode = null\r\n\t} else {\r\n\t\tinner = maybeInner!\r\n\t\tbeforeNode = beforeOrInner\r\n\t}\r\n\r\n\tconst startNode = document.createComment(\"<portal>\")\r\n\tconst endNode = document.createComment(\"</portal>\")\r\n\tparentNode.insertBefore(startNode, beforeNode)\r\n\tparentNode.insertBefore(endNode, beforeNode)\r\n\tonCleanup(() => {\r\n\t\tconst range = document.createRange()\r\n\t\trange.setStartBefore(startNode)\r\n\t\trange.setEndAfter(endNode)\r\n\t\trange.deleteContents()\r\n\t})\r\n\r\n\tassertStatic(() => {\r\n\t\trunWithInsertionState(parentNode, endNode, inner)\r\n\t})\r\n}\r\n\r\nexport function mountBody(inner: () => void) {\r\n\tif (document.body) {\r\n\t\taddPortal(document.body, null, inner)\r\n\t} else {\r\n\t\tconst savedOwner = getOwner()\r\n\t\twindow.addEventListener(\"load\", () => {\r\n\t\t\trunWithOwner(savedOwner, () => {\r\n\t\t\t\taddPortal(document.body, null, inner)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n\r\nexport function addAsyncReplaceable(\r\n\tsetupReplacements: (\r\n\t\treplaceInner: <T>(inner: () => T) => T\r\n\t) => void\r\n) {\r\n\treplacementArea(\r\n\t\taddNode(document.createComment(\"<async>\")),\r\n\t\taddNode(document.createComment(\"</async>\")),\r\n\t\t($r) => {\r\n\t\t\tconst replaceInnerOwner = new Owner()\r\n\t\t\trunWithInsertionState(null, null, () => {\r\n\t\t\t\t_updateState(true, false, getOwner(), undefined, () => {\r\n\t\t\t\t\tsetupReplacements((inner) => {\r\n\t\t\t\t\t\treplaceInnerOwner.reset()\r\n\r\n\t\t\t\t\t\treturn _updateState(true, false, replaceInnerOwner, undefined, () => {\r\n\t\t\t\t\t\t\treturn batch(() => {\r\n\t\t\t\t\t\t\t\treturn $r(inner)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t)\r\n}\r\n\r\nexport function addDynamic(inner: () => void): void {\r\n\treplacementArea(\r\n\t\taddNode(document.createComment(\"<dynamic>\")),\r\n\t\taddNode(document.createComment(\"</dynamic>\")),\r\n\t\t($r) => {\r\n\t\t\tcreateEffect(() => {\r\n\t\t\t\t$r(() => {\r\n\t\t\t\t\tretrack(inner)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t)\r\n}\r\n\r\nexport function addAsync<T>(inner: () => T): T {\r\n\tlet out: any\r\n\treplacementArea(\r\n\t\taddNode(document.createComment(\"<async-append>\")),\r\n\t\taddNode(document.createComment(\"</async-append>\")),\r\n\t\t($r) => {\r\n\t\t\t$r(() => {\r\n\t\t\t\tout = inner()\r\n\t\t\t})\r\n\t\t}\r\n\t)\r\n\treturn out!\r\n}\r\n\r\nexport function addIf(ifCond: () => any, inner: () => void) {\r\n\tconst conds: (() => boolean)[] = []\r\n\tconst inners: (() => void)[] = []\r\n\tconst nConds = createSignal(conds.length)\r\n\tfunction addStage(cond: () => boolean, inner: () => void) {\r\n\t\tconds.push(cond)\r\n\t\tinners.push(inner)\r\n\t\tnConds(conds.length)\r\n\t}\r\n\r\n\tconst ifStageMaker = {\r\n\t\telseif(cond: () => any, inner: () => void) {\r\n\t\t\taddStage(cond, inner)\r\n\t\t\treturn ifStageMaker\r\n\t\t},\r\n\t\telse(inner: () => void): void {\r\n\t\t\taddStage(() => true, inner)\r\n\t\t}\r\n\t}\r\n\r\n\taddStage(ifCond, inner)\r\n\r\n\taddAsyncReplaceable(($r) => {\r\n\t\tlet oldI = -1\r\n\t\tcreateEffect(() => {\r\n\t\t\tfor (let i = 0; i < nConds(); i++) {\r\n\t\t\t\tif (conds[i]()) {\r\n\t\t\t\t\tif (oldI !== i) {\r\n\t\t\t\t\t\toldI = i\r\n\t\t\t\t\t\t$r(inners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toldI = -1\r\n\t\t\t$r(() => { })\r\n\t\t})\r\n\t})\r\n\r\n\treturn ifStageMaker\r\n}\r\n\r\nexport { default as addFor } from \"./addFor.js\"\r\n", "//                       Ex: /about.html => about.html => about\nconst location = window.location.pathname.substring(1).replace(/\\.html$/, \"\")\n\nconst { protocol, hostname, port } = window.location\nexport const url = `${protocol}//${hostname}:${port}`\n\n// Reload the page when the user hits the 'back button'\nwindow.addEventListener('popstate', () => {\n    window.location.reload()\n})\n\n/**\n * Checks if a user is on a given page.\n * @param path The page to check\n * @returns A boolean function specifying if the user is on the given page\n */\nexport function pageIs(path: string | RegExp): boolean {\n    if (path instanceof RegExp) {\n        return path.test(location)\n    } else {\n        return path === location\n    }\n}\n\n/**\n * Redirects the user to a given page.\n * @param path The page to redirect to\n */\nexport function redirect(path: string): void {\n    if (!path.includes(\".\")) {\n        path += \".html\"\n    }\n\n    window.history.pushState(null, null, path)\n    window.location.reload()\n}\n\n/**\n * Replaces a user's current page with another.\n * @param path The page to be replaced with\n */\nexport function replace(path: string): void {\n    if (path !== \"\" && !path.includes(\".\")) {\n        path += \".html\"\n    }\n\n\n    window.location.replace(`${url}/${path}`)\n}", "import * as D from \"dynein\"\n\nconst { section, img, div, main, header, p, a } = D.elements\n\nexport function home(): void {\n    div({ class: \"column\" }, () => {\n        main({ class: \"content\" }, () => {\n            div({ class: \"bio\" }, () => {\n                img({ class: \"headshot\", src: \"assets/headshot.avif\" })\n\n                section({ class: \"container-vertical\" }, () => {\n                    header({ class: \"title\" }, \"Hello :)\")\n                    p({ class: \"description\" }, \"Welcome to my personal website!\")\n                })\n            })\n\n            div({ class: \"directory\" }, () => {\n                addItem({\n                    title: \"Projects\",\n                    description: \"Some cool projects I've worked on\",\n                    href: \"projects.html\"\n                })\n\n                addItem({\n                    title: \"About\",\n                    description: \"Learn all about me!\",\n                    href: \"about.html\"\n                })\n\n                addItem({\n                    title: \"Blog\",\n                    description: \"WIP - Come back later!\",\n                    href: \"index.html\"\n                })\n            })\n        })\n    })\n}\n\ntype DirectoryItem = {\n    title: string,\n    description: string,\n    href: string,\n}\n\nfunction addItem({ title, description, href }: DirectoryItem) {\n    a({ class: \"directory-item\", href }, () => {\n        p({ class: \"title\" }, title)\n        p({ class: \"description\" }, description)\n    })\n}", "import * as D from \"dynein\"\n\nconst { a, img, nav } = D.elements\nconst $ = D.createSignal\n\n\ntype Season = \"summer\" | \"fall\" | \"winter\"\nexport function header({ style, season }: { style?: string, season: Season }) {\n    nav({\n        class: `${season ?? \"summer\"} header`,\n        style\n    }, () => {\n        a({ href: \"index.html\" }, () => {\n            img({\n                class: \"header-image\",\n                src: \"assets/headshot.avif\"\n            })\n        })\n\n        a({ class: \"header-button\", href: \"index.html\" }, \"Home\")\n        a({ class: \"header-button\", href: \"projects.html\" }, \"Projects\")\n        a({ class: \"header-button\", href: \"about.html\" }, \"About\")\n        a({ class: \"header-button\", href: \"index.html\" }, \"Blog\")\n    })\n}", "import * as D from \"dynein\"\n\nconst { div, p, header, a, section } = D.elements\n\ntype Linkable = string | (() => HTMLAnchorElement)\ntype ProjectCardType = {\n    title: Linkable,\n    img: () => HTMLElement,\n    description: string | string[],\n    stack?: Linkable[]\n    reversed?: boolean\n}\n\nexport function projectCard({ title, description, img, reversed, stack }: ProjectCardType) {\n    div({\n        class: \"project-card\" + (reversed ? \" reverse\" : \"\")\n    }, () => {\n        img()\n\n        section({}, () => {\n            header({ class: \"title\" }, () => addLinkable(title))\n\n            for (const paragraph of listify(description)) {\n                p({ class: \"description\" }, paragraph)\n            }\n\n            if (stack) {\n                addStack(stack)\n            }\n        })\n    })\n}\n\nfunction addStack(stack: Linkable[]) {\n    p({ class: \"stack\" }, () => {\n        D.addText(\"Stack: \")\n\n        let first = true\n        for (const stackElement of stack) {\n            if (!first) {\n                D.addText(\", \")\n            }\n\n            addLinkable(stackElement)\n            first = false\n        }\n    })\n}\n\nfunction addLinkable(text: Linkable) {\n    if (typeof text === \"string\") {\n        D.addText(text)\n    } else {\n        text()\n    }\n}\n\n// If maybelList is a single element, wrap it in an array\nfunction listify<T>(maybeList: T | T[]): T[] {\n    return [].concat(maybeList)\n}", "import * as D from \"dynein\"\n\nconst { a, img, div } = D.elements\n\ntype IconButtonOptions = {\n    icon?: string,\n    color?: string,\n    text: string,\n    href: string\n}\n\nexport function iconButton({ icon, color, text, href }: IconButtonOptions) {\n    a({\n        href,\n        style: color ? `background-color: ${color};` : \"\",\n        rel: \"noopener noreferrer\",\n        target: \"_blank\"\n    }, () => {\n        div(() => {\n            if (icon) {\n                img({ src: icon })\n            }\n            D.addText(text)\n        })\n    })\n}", "import * as D from \"dynein\"\n\nimport { header, iconButton } from \"src/components\"\n\nconst { div, main, img, p, a, span } = D.elements\n\nexport function about(): void {\n    div({ class: \"about-column\" }, () => {\n        header({ season: \"winter\" })\n\n        main({ class: \"content\" }, () => {\n            img({ class: \"about-banner\", src: \"assets/about/banner.avif\" })\n\n            p({ class: \"title\" }, () => {\n                D.addText(\"Hello, I'm \")\n                split(\"Pedro\")\n                D.addText(\"!\")\n            })\n\n            p(() => {\n                D.addText(\"I am a senior Computer Science major and Music minor at Lafayette College. Although I have experience with full-stack development, I love working with back-end systems the most. I also really enjoy teaching myself new tools and technologies. For example, I recently taught myself how to use \")\n                a({ class: \"link\", href: \"https://www.docker.com/\", }, \"Docker\")\n                D.addText(\" (+more) by setting up my own self-hosted media server!\")\n            })\n\n            p(() => {\n                D.addText(\"Over the last two summers, I've had the opportunity to intern with \")\n                a({ class: \"link\", href: \"https://www.newspapersystems.com/\", }, \"Software Consulting Services\")\n                D.addText(\" / \")\n                a({ class: \"link\", href: \"https://www.sn1.live/\" }, \"SN1\")\n                D.addText(\" as a software developer. It was a blast getting to work both on real legacy systems and on their startup's new data visualization tools! My favorite project was implementing real-time group video calls for their latest (and yet-to-be-announced) application!\")\n            })\n\n            div({ class: \"buttons\" }, () => {\n                iconButton({\n                    text: \"GitHub\",\n                    href: \"https://github.com/nypedro\",\n                    color: \"#121613\",\n                    icon: \"assets/icons/github.svg\"\n                })\n                iconButton({\n                    text: \"LinkedIn\",\n                    href: \"https://www.linkedin.com/in/pedro-ds\",\n                    color: \"#007ebb\",\n                    icon: \"assets/icons/linkedin.svg\"\n                })\n                iconButton({\n                    text: \"Transcript\",\n                    href: \"assets/about/transcript.pdf\",\n                    color: \"#771b0f\",\n                    icon: \"assets/icons/transcript.svg\"\n                })\n                iconButton({\n                    text: \"Resume\",\n                    href: \"assets/about/resume.pdf\",\n                    color: \"#837c19\",\n                    icon: \"assets/icons/resume.svg\"\n                })\n            })\n        })\n    })\n}\n\nfunction split(str: string) {\n    for (const char of str) {\n        span({ class: \"waving\" }, char)\n    }\n}", "import * as D from \"dynein\"\nimport { header, projectCard } from \"../components\"\n\nconst { img, a, main, em } = D.elements\n\nexport function projects(): void {\n    main({ class: \"project-list\" }, () => {\n        header({ season: \"fall\" })\n\n        projectCard({\n            title: \"OneSearch\",\n            description: [\n                \"In my Databases course, my partner and I were tasked with creating a tool to visualize and compare statistics about the Pennsylvanian educational system.\",\n                \"While my partner created a web-based interface, I developed a series of Python scripts which scraped and cleaned public data from various government websites to automatically generate a comprehensive database.\"],\n            stack: [\n                link(\"Python\", \"https://www.python.org/\"),\n                link(\"SQLite\", \"https://sqlite.org/\"),\n                link(\"Typescript\", \"https://www.typescriptlang.org/\"),\n                link(\"React\", \"https://react.dev/\"),\n            ],\n            img: () => img({\n                src: \"/assets/projects/onesearch1.avif\"\n            }),\n        })\n\n        projectCard({\n            title: \"This Website\",\n            description: [\n                \"Over my winter break, I decided to practice my web design skills by finally creating this very website! To make sure I really understood the fundamentals, I decided to avoid libraries such as React or Bootstrap.\",\n                \"I've had a lot of fun building it from the ground up, doing my best to balance professionalism with silliness/creativity!\"],\n            stack: [\n                link(\"Typescript\", \"https://www.typescriptlang.org/\"),\n                link(\"Dynein\", \"https://github.com/kerwizzy/Dynein/tree/master\"),\n                link(\"Sass\", \"https://sass-lang.com\"),\n                link(\"GitHub Pages\", \"https://sass-lang.com\")\n            ],\n            img: () => img({\n                src: \"/assets/projects/website.avif\"\n            }),\n            reversed: true\n        })\n\n        projectCard({\n            title: \"Self-Hosting    \",\n            description: \"I've (not-so-) recently fallen into the self-hosting rabbithole, and finally had the chance to set one up myself. Although I'm operating on a college student budget, I currently self-host a network-wide ad blocker, NAS, and media server. Everything is fully backed-up using 3-2-1 backup rule!\",\n            stack: [\n                link(\"Pi-hole\", \"https://pi-hole.net/\"),\n                link(\"Backblaze B2\", \"https://www.backblaze.com/cloud-storage\"),\n                link(\"copyparty\", \"https://github.com/9001/copyparty\"),\n                link(\"nginx\", \"https://nginx.org/\"),\n                link(\"Docker\", \"https://www.docker.com/\"),\n                link(\"Jellyfin\", \"https://jellyfin.org/\"),\n                link(\"Tailscale\", \"https://tailscale.com/\"),\n            ],\n            img: () => img({\n                src: \"/assets/projects/homelab.avif\"\n            }),\n        })\n\n        projectCard({\n            title: \"SQL Server\",\n            description: \"As a group project for my Operating Systems course, my partner and I created a custom SQL-ish database and webserver. The system is capable of performing all the typical CRUD operations, and can even support multiple concurrent connections!\",\n            stack: [\n                link(\"C\", \"https://en.wikipedia.org/wiki/C_(programming_language)\"),\n                link(\"HTTP\", \"https://en.wikipedia.org/wiki/HTTP\"),\n                link(\"Common Gateway Interface\", \"https://en.wikipedia.org/wiki/Common_Gateway_Interface\")\n            ],\n            img: () => img({\n                src: \"/assets/projects/sql-server.avif\"\n            }),\n            reversed: true\n        })\n\n        projectCard({\n            title: \"Game Bots\",\n            description: [\n                \"Inspired by creators such as Games Computers Play, CodeNoodles, and Code Bullet, I made a few Python scripts to automatically play some simple games for me.\",\n                \"Using image processing, these bots can react to the games, allowing them to reach inhumanly high scores. So far, I've made bots for Piano Tiles, Swords & Souls, and Kuku Kube.\"],\n            stack: [\n                link(\"Python\", \"https://www.python.org/\"),\n                link(\"PyAutoGUI\", \"https://pyautogui.readthedocs.io/en/latest/\"),\n                link(\"Pillow\", \"https://pillow.readthedocs.io/en/stable/\")\n            ],\n            img: () => img({\n                src: \"/assets/projects/bots.avif\"\n            }),\n        })\n    })\n}\n\nfunction link(text: string, href: string) {\n    return () => a({\n        class: \"link\",\n        target: \"_blank\", // Open in new tab,\n        rel: \"noopener noreferrer\", // Protect my legacy browser peeps :)\n        href\n    }, text)\n}", "import * as D from \"dynein\"\nimport * as router from \"./utils/router\"\nimport * as pages from \"./pages\"\nimport * as cookies from \"./utils/cookies\"\n\nconst { p } = D.elements\n\nD.createRoot(() => {\n    D.mountBody(() => {\n        if (router.pageIs(/^(index|home)?$/)) {\n            pages.home()\n        } else if (router.pageIs(\"about\")) {\n            pages.about()\n        } else if (router.pageIs(\"projects\")) {\n            pages.projects()\n        } else {\n            p(\"Unknown page\")\n        }\n    })\n})"],
  "mappings": "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",
  "names": ["a", "a", "img", "header", "a", "img", "div", "p", "header", "a", "section", "img", "a", "img", "div", "div", "main", "img", "p", "a", "header", "img", "a", "main", "header", "p"]
}
